* Polkavm
** ProgramBlob

A partially deserialized PolkaVM program, composed by:
```rust
pub struct ProgramBlob<'a> {
    blob: CowBytes<'a>,

    bss_size: u32,
    stack_size: u32,

    ro_data: Range<usize>,
    rw_data: Range<usize>,
    exports: Range<usize>,
    imports: Range<usize>,
    code: Range<usize>,

    debug_strings: Range<usize>,
    debug_function_ranges: Range<usize>,
    debug_function_info: Range<usize>,
}
```
CawBytes is just a wrapper over a Cow<'a, u8>

*** parse function

1. Make sure the bytes blob starts with BLOB_MAGIC
   ```sh
    pub const BLOB_MAGIC: [u8; 4] = [b'P', b'V', b'M', b'\0'];
   ```
2. Init the Reader
3. read a byte to extract the BlobVersion
   if different from BLOB_VERSION_V1 return Err
4. read another byte the extract the SECTION
   1. If the section is SECTION_MEMORY_CONFIG then the parser will expect right after
      + section_length
      + bss_size
      + stack_size
   2. check that the section_length described correctly the encoding of bss_size and stack_size
   3. read another byte to extract the new section
5. All the other sections are now read and the ProgramBlob is filled up with all the ranges that compose the polkavm executable

   and the orther of the sections is:
   1. SECTION_RO_DATA
   2. SECTION_RW_DATA
   3. SECTION_IMPORTS
   4. SECTION_EXPORTS
   5. SECTION_CODE
   6. SECTION_OPT_DEBUG_STRINGS
   7. SECTION_OPT_DEBUG_FUNCTION_INFO
   8. SECTION_OPT_DEBUG_FUNCTION_RANGES

   then there are some optional sections ans last the SECTION_END_OF_FILE (just 0)
*** imports

+ Stucture

| what              | size                    |
| number of imports | varint                  |
| fn_protoype       | fn_protoype * n_imports |

Imports are things imported from the blob, can be seen as "Host Function"

#+BEGIN_SRC rust
pub fn imports(&'_ self) -> impl IteratorrItem = Result<ProgramImport, ProgramParseError>> + Clone + '_ {
#+END_SRC

where `ProgramParseError` is just a Wrapper over `enum ProgramParseErrorKind` (TODO: WHY?) and:
#+BEGIN_SRC rust
pub struct ProgramImport<'a> {
    /* SUPPOSITION: (TODO: make sure is true)
       this is the index of the function inside the import section
    ,**/
    index: u32, (TODO: WHAT IS THAT?)
    /* SUPPOSITION: (TODO: make sure is true)
       Descriptor of the import, it contains: name, arg_count, args and return type
    ,**/
    prototype: ExternFnPrototype<'a>,
}
#+END_SRC


INTERESTING: the iterator is implemented in the function itself

(TODO: The logic of the iterator is not straight forward)

#+BEGIN_SRC rust
enum State {
    Uninitialized,
    Pending(u32),
    Finished,
}

struct ImportIterator<'a> {
    state: State,
    reader: Reader<'a>,
}

impl<'a> ImportIterator<'a> {
    fn read_next(&mut self) -> Result<Option<ProgramImport<'a>>, ProgramParseError> {
        // THIS TRICK OF USING REPLACE TO MAKE THE CODE BETTER THE FOLLOWING CODE IS INCREDIBLE
        let remaining = match core::mem::replace(&mut self.state, State::Finished) {
            ...
    }
}

impl<'a> Iterator for ImportIterator<'a> { ... }
#+END_SRC

The function return an ImportIterator object and initially it is:

#+begin_src  rust
ImportIterator {
    state: if self.imports != (0_usize..0_usize) {
        // if there are imports then the iterator is Uninitialized
        State::Uninitialized
    } else {
        // if the range is EMPTY then the iterator is finished
        State::Finished
    },
    // just return a Reader object over a precise section
    reader: self.get_section_reader(self.imports.clone()),
}
#+end_src

*** instructions

+ structure
| what | size |
|      |      |

A struct is defined to iterate over the instructions

#+begin_src rust
struct CodeIterator<'a> {
    code_section_position: usize,
    position: usize,
    code: &'a [u8],
}
#+end_src

and the first instantiation of this struct is:
#+begin_src rust
CodeIterator {
    // lower bound of the range, starting point of the code sections
    code_section_position: self.code.start,
    // beginning of the section
    position: 0,
    // this method return the code section in a raw format (&[u8])
    // it just extrapolate from the blob the code range
    code: self.code(),
}
#+end_src

NOW to iterate over instructions the `next` method is called and the iterator works in this way:
1. the return type of the iteration is `RawInstruction`
2. TODO


** ExternTy
Just an enum over all the possible types that the blob can provide to the imports, currently

#+begin_src rust
pub enum ExternTy {
    I32 = 1,
    I64 = 2,
}
#+end_src

*** try_deserialize(value)
really straight forward
1 -> `I32`
1 -> `I64`


** Reader
```rust
struct Reader<'a> {
    blob: &'a [u8],
    position: usize,
    previous_position: usize,
}
```
*** read_byte
This function should easily read the next byte BUT it does in a weird way,
calling `read_slice_as_range`

*** read_slice_as_range (count)
range = range (current_position, current_position + count)

Just make sure that is inside the blob, update position and prev_position and finally return the range.

PAY ATTENTION: this function is used in `read_section_range_into` because it makes sure the range make sense and update the position of the reader

*** read_varint
Read the next bytes as an Integer that follows a Variable Length Encoding
Only at most 32-bit values are supported.

TODO: understand this encoding and why is here, is it present in ELF file also? or just optimization by @koute

*** read_section_range_into (&mut out_section, &mut out_range, expected_section)
out_section is the code of the next section (readed by the caller of this function)

if out_section differs from expected_section then the function returns `Ok(())` immediately
otherwise:
1. read the section length (varint encoded)
2. Use read_slice_as_range to make sure the section length is correct
   ```rust
   *out_range = self.read_slice_as_range(section_length)?;
   ````
3. read the byte just after the ended section to update out_section with the new section code
*** read_extern_fn_prototype

Structure of a fn_prototype:

| what               | size                      |
|--------------------+---------------------------|
| length of the name | varint                    |
| name               | dependent of the previous |
| arg_count          | varint                    |
| args               | byte * arg_count          |
| return_ty          | byte                      |

1. read the name of the fn_prototype using read_string_with_length
2. next varint is the
3. make sure the specified arg_count is not more then `crate::abi::VM_MAXIMUM_EXTERN_ARG_COUNT`
4. allocate the space for the arguments types
    -> (TODO) why ` = [None; crate::abi::VM_MAXIMUM_EXTERN_ARG_COUNT]` ? why use always the max argumentes?
              just to make it easier? it's only 6 enums so nothing so bad at runtime
5. loop over the expected arguments
   1. each argument is deserialized to extract the type -> `ExternTy::try_deserialize`
   2. `args[nth_arg as usize] = Some(ty);` and then inserted into the just allocated args
6. the return type is then decoded, it could be 0 -> None or another ExternTy that needs to be deserialized
7. TADAAANN the fn_prototype is decoded

*** read_string_with_length
#+BEGIN_SRC rust
// decode the length of the string (varint encoded)
let length = self.read_varint()?;
// get the range fo the string making sure it does not overflow
let range = self.read_slice_as_range(length)?;
// just extract a slice from it
let slice = &self.blob[range];
// decode the slice as utf8 string
core::str::from_utf8(slice)
    .ok()
    .ok_or(ProgramParseError(ProgramParseErrorKind::FailedToReadStringNonUtf {
        offset: self.previous_position,
    }))
#+END_SRC


** Config
#+BEGIN_SRC rust
pub struct Config {
    pub(crate) backend: Option<Backend>,
    pub(crate) trace_execution: bool,
    pub(crate) allow_insecure: bool,
}
#+END_SRC

Just a wrapper over some information of the execution type
+ backend :: could be Compiler or Interpreter while
+ trace_execution :: (TODO) I think just a way to keep track of the function stack and other stuff
+ allow_insecure :: (TODO)


** Engine

#+BEGIN_SRC rust
pub struct Engine {
    config: Config,
}
#+END_SRC

Just a wrapper over the Config

*** new(&Config)
It just create the Engine structure making sure that the backend is supported, Interpreter is always true while Compiler return a constant that currently is true (maybe this will be under some sort of cfg based on the architecture the machine is running on? because currently risc-v is NOT compiled to arm but only x86_64)

Plus it does this check
#+BEGIN_SRC rust
#[allow(clippy::collapsible_if)]
if !config.allow_insecure {
    if config.trace_execution {
        bail!("cannot enable trace execution: `set_allow_insecure`/`POLKAVM_ALLOW_INSECURE` is not enabled");
    }
}
#+END_SRC
trace seems to be enabled only and only if also allow_insecure is true

Why that usage of clippy? I'm not sure but it could be just a way to let the code on our side more elastic and easy to modify if other cases will be added, while clippy can neast the ifs


** Module
#+BEGIN_SRC rust
/// A compiled PolkaVM program module.
pub struct Module(Arc<ModulePrivate>);
#+END_SRC

*** from_blob(engine: &Engine, blob: &ProgramBlob)
Creates a new module from a deserialized program `blob`

1. Parsing imports
   1. iterate over the imports, we now know which imports the blob expects
   2. fill `BTreeMap<u32, ProgramImport>` (TODO: why the index is present as key and ALSO in the value?)
   3. + checks over the max number of imports allowed
2. Parsing Code
   1. Init `jump_target_to_instruction: HashMap<u32, u32>` and `instructions: Vec<RawInstruction>`

      (TODO: `jump_target_to_instruction` is not so clear for not to me, why the key is the target and the value is the instruction that jumps to the target?)

   2. Iterate over instructions
      There is a match over the Opcode of the instruciton
      + Opcode::jump_target
         (TODO: insted of `instruction.raw_imm_or_reg()` a second time could be used `target`)
         the jump targets are added to the map `jump_target_to_instruction`
      + Opcode::ecalli
         (TODO: are this opcode someting like syscall in x86_64?)
         there is a check that the value associated to `instruction.raw_imm_or_reg()` is PRESENT in the imports map, otherwhise it fails
   3. instructions are addded in the vec `instructions`
   4. and VM_MAXIMUM_INSTRUCTION_COUNT is checked




** Linker

#+BEGIN_SRC rust
pub struct Linker<T> {
    host_functions: HashMap<String, ExternFnArc<T>>,
    #[allow(clippy::type_complexity)]
    fallback_handler: Option<FallbackHandlerArc<T>>,
    phantom: core::marker::PhantomData<T>,
}
#+END_SRC

T = seems could be a shared state that can be used in the different host functions

*** new(_engine: &Engine)
default values are used, engine is NOT used and T = ()

*** func_wrap<Params, Args>(&mut self, name: &str, func: impl IntoExternFn<T, Params, Args>)

a way to register host functions

*** instantiate_pre(&self, module: &Module)
Link exports value of the module to registered host functions in the Linker

Return type: InstancePre

**** How it works? (TODO)



** InstancePre
#+BEGIN_SRC rust
pub struct InstancePre<T>(Arc<InstancePrePrivate<T>>);
#+END_SRC

It is just a pre stage of a real instance

*** instantiate
the pre instance can be instantiated in two ways Compiled or Interpreted with the Tracing enabled

**** How it works? (TODO)

*** get_typed_func<FnArgs, FnResult>(&self, name: &str)
Returns a **typed** handle to a function of a given name exported by the module.

*** get_func(&self, name: &str)
Returns a handle to a function of a given name exported by the module.


** RawInstruction

#+begin_src rust
 pub struct RawInstruction {
     //ok, just the opcode of the instruction
     //it could be seen as the "identifier" of the instruction in the binary format
     op: u8,
     // maybe the register used in the instruction? (TODO)
     regs: u8,
     // LOL IDK (TODO)
     imm_or_reg: u32,
 }
#+end_src

There seem to be only 4 types of opcodes:
- name_argless :: (&mut self), no input args
- name_with_imm :: (&mut self, imm: u32), only one arg
- name_with_regs3 :: (&mut self, reg1: Reg, reg2: Reg, reg3: Reg), three registers as input
- name_with_regs2_imm :: (&mut self, reg1: Reg, reg2: Reg, imm: u32), 2 registers and imm input

How instructions are defined?
+ `define_opcodes!` accept the opcodes and its binary values,
  the opcodes are divided as before
+ the macro define a trait `InstructionVisitor` that requires to self to implement a method for each instruction
  + this trait is implemented by `core::fmt::Formatter`
+ then the method `visit` is implemented for `RawInstruction`
  + What it does is to accept `impl InstructionVisitor` and match on the Opcode to call the proper method on the `impl InstructionVisitor`, the only struct to implement this trait is `core::fmt::formatter` -> this let me think how this method is used to just 'debug' instructions in fact:
    #+begin_src rust
    impl core::fmt::Display for RawInstruction {
        fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
            self.visit(fmt)
        }
    }
    #+end_src
    visit is just used in the `Display` method
+ After the things with the `InstructionVisitor` trait there is another call to the `define_opcodes!` macro, but another branch:
  #+begin_src rust
  define_opcodes!(
      @impl_shared
      $($name_argless = $value_argless,)+
      $($name_with_imm = $value_with_imm,)+
      $($name_with_regs3 = $value_with_regs3,)+
      $($name_with_regs2_imm = $value_with_regs2_imm,)+
  );
  #+end_src
  as we can see the division between the different instructions is removed, the marco indeed accept only a list of `name = value`
  #+begin_src rust
    (@impl_shared $($name:ident = $value:expr,)+) => { ... }
  #+end_src
  + What this branch does?
    #+begin_src rust
    // It define an enum to represent all the opcodes

    #[repr(u8)] // in a fieldless enum what this does is to treat
                // at runtime the enum literally like an u8, so the value
                // is associated to each variant
                // more infos: https://doc.rust-lang.org/nomicon/other-reprs.html#repru-repri
    // + other derive
    pub enum Opcode {
        $(
            $name = $value,
        )+
    }

    // Implementation of a method able to convert a byte to an opcode
    impl Opcode {
        pub fn from_u8(byte: u8) -> Option<Opcode> {
            match byte {
                $($value => Some(Opcode::$name),)+
                _ => None
            }
        }
    }

    // and then construct a 256 value slice to store which opcodes are valid
    const IS_INSTRUCTION_VALID_CONST: [bool; 256] = {
        let mut is_valid = [false; 256];
        $(
            is_valid[$value] = true;
        )+
        is_valid
    };
    #+end_src

**What are though `regs` and `imm_or_reg`???**

useful things to know:
+ `Reg` enum :: there are 14 variants (so 14 registers?)
+ ALL_NON_ZERO :: is a const array containing the list of all of the VM's registers, except the zero register.
+ ARG_REGS :: const array of all argument registers
+ MAX_INSTRUCTION_LENGTH :: it is the max length of a register, it is evaluated ad `MAX_VARINT_LENGTH + 2`, where `MAX_VARINT_LENGTH = 5`

*** List of all instructions

|---------------------------------------+-------------|
| 1 byte instructions                   |             |
| Instructions with no args.            |             |
|---------------------------------------+-------------|
| trap                                  | 0b00_000000 |
|---------------------------------------+-------------|
| 1-6 byte instructions                 |             |
| Instructions with args: imm           |             |
|---------------------------------------+-------------|
| jump_target                           | 0b01_000000 |
| ecalli                                | 0b01_111111 |
|---------------------------------------+-------------|
| 3 byte instructions                   |             |
| Instructions with args: reg, reg, reg |             |
|---------------------------------------+-------------|
| set_less_than_unsigned                | 0b10_000000 |
| set_less_than_signed                  | 0b10_000001 |
| shift_logical_right                   | 0b10_000010 |
| shift_arithmetic_right                | 0b10_000011 |
| shift_logical_left                    | 0b10_000100 |
| or                                    | 0b10_000101 |
| and                                   | 0b10_000110 |
| xor                                   | 0b10_000111 |
| add                                   | 0b10_001000 |
| sub                                   | 0b10_001001 |
| mul                                   | 0b10_010000 |
| mul_upper_signed_signed               | 0b10_010001 |
| mul_upper_unsigned_unsigned           | 0b10_010010 |
| mul_upper_signed_unsigned             | 0b10_010011 |
| div_unsigned                          | 0b10_010100 |
| div_signed                            | 0b10_010101 |
| rem_unsigned                          | 0b10_010110 |
| rem_signed                            | 0b10_010111 |
|---------------------------------------+-------------|
| 2-7 byte instructions                 |             |
| Instructions with args: reg, reg, imm |             |
|---------------------------------------+-------------|
| set_less_than_unsigned_imm            | 0b11_000000 |
| set_less_than_signed_imm              | 0b11_000001 |
| shift_logical_right_imm               | 0b11_000010 |
| shift_arithmetic_right_imm            | 0b11_000011 |
| shift_logical_left_imm                | 0b11_000100 |
| or_imm                                | 0b11_000101 |
| and_imm                               | 0b11_000110 |
| xor_imm                               | 0b11_000111 |
| add_imm                               | 0b11_001000 |
| store_u8                              | 0b11_010000 |
| store_u16                             | 0b11_010010 |
| store_u32                             | 0b11_010100 |
| load_u8                               | 0b11_100000 |
| load_i8                               | 0b11_100001 |
| load_u16                              | 0b11_100010 |
| load_i16                              | 0b11_100011 |
| load_u32                              | 0b11_100100 |
| branch_less_unsigned                  | 0b11_110000 |
| branch_less_signed                    | 0b11_110001 |
| branch_greater_or_equal_unsigned      | 0b11_110010   |
| branch_greater_or_equal_signed        | 0b11_110011 |
| branch_eq                             | 0b11_110100 |
| branch_not_eq                         | 0b11_110101 |
| jump_and_link_register                | 0b11_111111 |
|---------------------------------------+-------------|

**** Structure of an instruction
***** 1֯ byte = opcode
****** if opcode_msb = 0 and (opcode_msb - 1) = 0
END, the instruction is 1B long
****** else if opcode_msb = 0 and (opcode_msb - 1) = 1
******* 2֯ to 6֯ byte = immediate
the immediate value is varint encoded
****** else if opcode_msb = 1 and (opcode_msb - 1) = 0
******* 2֯ byte = reg2 & reg1
******* 3֯ byte = reg3
****** else if opcode_msb = 1 and (opcode_msb - 1) = 1
******* 2֯ byte = reg2 & reg1
******* 3֯ to 7֯ byte = immediate
the immediate value is varint encoded

*** new_argless(opcode)
just a `RawInstruction` with no args, only the opcode
*** new_with_imm(opcode, imm)
*** new_with_regs3(opcode, reg1, reg2, reg3)
*** new_with_regs2_imm(opcode, reg1, reg2, imm)
*** op
just return the enum Opcode
*** reg1
return an enum Reg, the reg1 is the lsh (least significant half) of `regs` -> `self.regs & 0b00001111`
*** reg2
return an enum Reg, the reg2 is the msh (most significant half) of `regs` -> `self.regs >> 4`
*** reg3
return an enum Reg, the reg3 is stored in `imm_or_reg`
*** raw_op
*** raw_imm_or_reg

*** deserialize

#+begin_src rust
pub fn deserialize(input: &[u8]) -> Option<(usize, Self)> { ... }
#+end_src

The return type is a tuple, why?:
+ usize -> length of the encode instruction (bytes)
+ RawInstruction -> deserialized instruction

What the function does?
1. read the first byte to extract the opcode and make sure it is valid using the `IS_INSTRUCTION_VALID` array
2. set the position to 1
3. check the msb to see if REG1 and REG2 are present (second byte)
   1. Check if the registers are valid, registers could be in the two halfs of the byte only values from 0 to 13, NOT 14 or 15
4. check msb or (msb - 1)
   1. the third thing could be REG3 (third byte) or an immediate value varint encoded (5B max)
5. return the decoded instruciton and its encoded length

*** serialize_into(buffer)
1. make sure the buffer is enough big (MAX_INSTRUCTION_LENGTH)
2. store the opcode in the position 0
3. write regs in position 1 if the opcode expect registers
4. write the imm_or_reg in position 1 or 2 if expected by the register

*** TESTs
(TODO: skipped for now)
