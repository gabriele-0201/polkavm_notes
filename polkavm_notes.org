* Polkavm
** ProgramBlob

A partially deserialized PolkaVM program, composed by:
```rust
pub struct ProgramBlob<'a> {
    blob: CowBytes<'a>,

    bss_size: u32,
    stack_size: u32,

    ro_data: Range<usize>, // read only data (usually constants)
    rw_data: Range<usize>, // read write data (usually variables)
    exports: Range<usize>,
    imports: Range<usize>,
    code: Range<usize>,

    debug_strings: Range<usize>,
    debug_function_ranges: Range<usize>,
    debug_function_info: Range<usize>,
}
```
CawBytes is just a wrapper over a Cow<'a, u8>

*** parse function

1. Make sure the bytes blob starts with BLOB_MAGIC
   ```sh
    pub const BLOB_MAGIC: [u8; 4] = [b'P', b'V', b'M', b'\0'];
   ```
2. Init the Reader
3. read a byte to extract the BlobVersion
   if different from BLOB_VERSION_V1 return Err
4. read another byte the extract the SECTION
   1. If the section is SECTION_MEMORY_CONFIG then the parser will expect right after
      + section_length
      + bss_size
      + stack_size
   2. check that the section_length described correctly the encoding of bss_size and stack_size
   3. read another byte to extract the new section
5. All the other sections are now read and the ProgramBlob is filled up with all the ranges that compose the polkavm executable

   and the orther of the sections is:
   1. SECTION_RO_DATA
   2. SECTION_RW_DATA
   3. SECTION_IMPORTS
   4. SECTION_EXPORTS
   5. SECTION_CODE
   6. SECTION_OPT_DEBUG_STRINGS
   7. SECTION_OPT_DEBUG_FUNCTION_INFO
   8. SECTION_OPT_DEBUG_FUNCTION_RANGES

   then there are some optional sections ans last the SECTION_END_OF_FILE (just 0)
*** imports

+ Structure
| what              | size                                                                                      |
| number of imports | varint                                                                                    |
| index             | before each function there is a varint encoding the index of the following fn * n_imports |
| fn_protoype       | fn_protoype * n_imports                                                                   |

Imports are things imported from the blob, can be seen as "Host Function"

#+BEGIN_SRC rust
pub fn imports(&'_ self) -> impl IteratorrItem = Result<ProgramImport, ProgramParseError>> + Clone + '_ {
#+END_SRC

where `ProgramParseError` is just a Wrapper over `enum ProgramParseErrorKind` (TODO: WHY?) and:
#+BEGIN_SRC rust
pub struct ProgramImport<'a> {
    /* SUPPOSITION: (TODO: make sure is true)
       this is the index of the function inside the import section
    ,**/
    index: u32, (TODO: WHAT IS THAT?)
    /* SUPPOSITION: (TODO: make sure is true)
       Descriptor of the import, it contains: name, arg_count, args and return type
    ,**/
    prototype: ExternFnPrototype<'a>,
}
#+END_SRC


INTERESTING: the iterator is implemented in the function itself

(TODO: The logic of the iterator is not straight forward)

#+BEGIN_SRC rust
enum State {
    Uninitialized,
    Pending(u32),
    Finished,
}

struct ImportIterator<'a> {
    state: State,
    reader: Reader<'a>,
}

impl<'a> ImportIterator<'a> {
    fn read_next(&mut self) -> Result<Option<ProgramImport<'a>>, ProgramParseError> {
        // THIS TRICK OF USING REPLACE TO MAKE THE CODE BETTER THE FOLLOWING CODE IS INCREDIBLE
        let remaining = match core::mem::replace(&mut self.state, State::Finished) {
            ...
    }
}

impl<'a> Iterator for ImportIterator<'a> { ... }
#+END_SRC

The function return an ImportIterator object and initially it is:

#+begin_src  rust
ImportIterator {
    state: if self.imports != (0_usize..0_usize) {
        // if there are imports then the iterator is Uninitialized
        State::Uninitialized
    } else {
        // if the range is EMPTY then the iterator is finished
        State::Finished
    },
    // just return a Reader object over a precise section
    reader: self.get_section_reader(self.imports.clone()),
}
#+end_src

*** instructions

+ structure
| what | size |
|      |      |

A struct is defined to iterate over the instructions

#+begin_src rust
struct CodeIterator<'a> {
    code_section_position: usize,
    position: usize,
    code: &'a [u8],
}
#+end_src

and the first instantiation of this struct is:
#+begin_src rust
CodeIterator {
    // lower bound of the range, starting point of the code sections
    code_section_position: self.code.start,
    // beginning of the section
    position: 0,
    // this method return the code section in a raw format (&[u8])
    // it just extrapolate from the blob the code range
    code: self.code(),
}
#+end_src

NOW to iterate over instructions the `next` method is called and the iterator works in this way:
1. the return type of the iteration is `Result<RawInstruction, ProgramParseError>`
2. `let slice = &self.code[self.position..];`
   1. if empty return None
3. Deserialize the slice getting out an instruction and its length
   1. if the instruction is deserialized correctly then the position in the slice is updated and returned the instruction
4. if there is a problem in the deserialization the error is reported with the offset where the instruciton is not correct
*** exports
Equal to the function import, the only different is that the return type of the iterator is `ProgramImport<'a>`

#+begin_src rust
pub struct ProgramExport<'a> {
    address: u32, // this is the address of the function in the code
    prototype: ExternFnPrototype<'a>,
}
#+end_src

+ And the Structure change a bit
| what              | size                                                                                      |
| number of exports | varint                                                                                    |
| address      | before each function there is a varint encoding the address of the following fn * n_exports |
| fn_protoype       | fn_protoype * n_exports                                                                   |

** ExternTy
Just an enum over all the possible types that the blob can provide to the imports, currently

#+begin_src rust
pub enum ExternTy {
    I32 = 1,
    I64 = 2,
}
#+end_src

*** try_deserialize(value)
really straight forward
1 -> `I32`
1 -> `I64`


** Reader
```rust
struct Reader<'a> {
    blob: &'a [u8],
    position: usize,
    previous_position: usize,
}
```
*** read_byte
This function should easily read the next byte BUT it does in a weird way,
calling `read_slice_as_range`

*** read_slice_as_range (count)
range = range (current_position, current_position + count)

Just make sure that is inside the blob, update position and prev_position and finally return the range.

PAY ATTENTION: this function is used in `read_section_range_into` because it makes sure the range make sense and update the position of the reader

*** read_varint
Read the next bytes as an Integer that follows a Variable Length Encoding
Only at most 32-bit values are supported.

TODO: understand this encoding and why is here, is it present in ELF file also? or just optimization by @koute

*** read_section_range_into (&mut out_section, &mut out_range, expected_section)
out_section is the code of the next section (readed by the caller of this function)

if out_section differs from expected_section then the function returns `Ok(())` immediately
otherwise:
1. read the section length (varint encoded)
2. Use read_slice_as_range to make sure the section length is correct
   ```rust
   *out_range = self.read_slice_as_range(section_length)?;
   ````
3. read the byte just after the ended section to update out_section with the new section code
*** read_extern_fn_prototype

Structure of a fn_prototype:

| what               | size                      |
|--------------------+---------------------------|
| length of the name | varint                    |
| name               | dependent of the previous |
| arg_count          | varint                    |
| args               | byte * arg_count          |
| return_ty          | byte                      |

1. read the name of the fn_prototype using read_string_with_length
2. next varint is the
3. make sure the specified arg_count is not more then `crate::abi::VM_MAXIMUM_EXTERN_ARG_COUNT`
4. allocate the space for the arguments types
    -> (TODO) why ` = [None; crate::abi::VM_MAXIMUM_EXTERN_ARG_COUNT]` ? why use always the max argumentes?
              just to make it easier? it's only 6 enums so nothing so bad at runtime
5. loop over the expected arguments
   1. each argument is deserialized to extract the type -> `ExternTy::try_deserialize`
   2. `args[nth_arg as usize] = Some(ty);` and then inserted into the just allocated args
6. the return type is then decoded, it could be 0 -> None or another ExternTy that needs to be deserialized
7. TADAAANN the fn_prototype is decoded

*** read_string_with_length
#+BEGIN_SRC rust
// decode the length of the string (varint encoded)
let length = self.read_varint()?;
// get the range fo the string making sure it does not overflow
let range = self.read_slice_as_range(length)?;
// just extract a slice from it
let slice = &self.blob[range];
// decode the slice as utf8 string
core::str::from_utf8(slice)
    .ok()
    .ok_or(ProgramParseError(ProgramParseErrorKind::FailedToReadStringNonUtf {
        offset: self.previous_position,
    }))
#+END_SRC


** Config
#+BEGIN_SRC rust
pub struct Config {
    pub(crate) backend: Option<Backend>,
    pub(crate) trace_execution: bool,
    pub(crate) allow_insecure: bool,
}
#+END_SRC

Just a wrapper over some information of the execution type
+ backend :: could be Compiler or Interpreter while
+ trace_execution :: (TODO) I think just a way to keep track of the function stack and other stuff
+ allow_insecure :: (TODO)


** Engine

#+BEGIN_SRC rust
pub struct Engine {
    config: Config,
}
#+END_SRC

Just a wrapper over the Config

*** new(&Config)
It just create the Engine structure making sure that the backend is supported, Interpreter is always true while Compiler return a constant that currently is true (maybe this will be under some sort of cfg based on the architecture the machine is running on? because currently risc-v is NOT compiled to arm but only x86_64)

Plus it does this check
#+BEGIN_SRC rust
#[allow(clippy::collapsible_if)]
if !config.allow_insecure {
    if config.trace_execution {
        bail!("cannot enable trace execution: `set_allow_insecure`/`POLKAVM_ALLOW_INSECURE` is not enabled");
    }
}
#+END_SRC
trace seems to be enabled only and only if also allow_insecure is true

Why that usage of clippy? I'm not sure but it could be just a way to let the code on our side more elastic and easy to modify if other cases will be added, while clippy can neast the ifs


** Module
#+BEGIN_SRC rust
/// A compiled PolkaVM program module.
pub struct Module(Arc<ModulePrivate>);

struct ModulePrivate {
    debug_trace_execution: bool,
    exports: Vec<ProgramExport<'static>>,
    imports: BTreeMap<u32, ProgramImport<'static>>,
    export_index_by_name: HashMap<String, usize>,
    instructions: Vec<RawInstruction>,
    jump_target_to_instruction: HashMap<u32, u32>, // (TODO: still BOH)

    blob: Option<ProgramBlob<'static>>,
    // AS WE CAN SEE -> in a module are accepted both a compiled and interpreted module
    compiled_module: Option<CompiledModule>,
    interpreted_module: Option<InterpretedModule>,
}
#+END_SRC

*** from_blob(engine: &Engine, blob: &ProgramBlob)
Creates a new module from a deserialized program `blob`

1. Parsing imports
   1. iterate over the imports, we now know which imports the blob expects
   2. fill `BTreeMap<u32, ProgramImport>` (TODO: why the index is present as key and ALSO in the value?)
   3. + checks over the max number of imports allowed
2. Parsing Code
   1. Init `jump_target_to_instruction: HashMap<u32, u32>` and `instructions: Vec<RawInstruction>`

      (TODO: `jump_target_to_instruction` is not so clear for not to me, why the key is the target and the value is the instruction that jumps to the target?)

   2. Iterate over instructions (using the `ProgramBlob::instructions` method)
      There is a match over the Opcode of the instruciton
      + Opcode::jump_target
         (TODO: instead of `instruction.raw_imm_or_reg()` a second time could be used `target`)
         the jump targets are added to the map `jump_target_to_instruction`
         BUT there if the key (target) is duplicated into the map then it is an ERROR (TODO: WHY??) <------------ why two different instructions can't jump on the same target???
      + Opcode::ecalli
         (TODO: are this opcode something like syscall in x86_64?)
         there is a check that the value associated to `instruction.raw_imm_or_reg()` is PRESENT in the imports map, otherwhise it fails
   3. instructions are addded in the vec `instructions`
   4. and VM_MAXIMUM_INSTRUCTION_COUNT is checked
3. Parsing exports
   1. iterate over the exports
   2. check that the `export.address` point to a jump target instruction (TODO: WHY???) <-------- AAKJHDLAKJHDLKADKJAHDlkjh
   3. check the max number of exports (VM_MAXIMUM_EXPORT_COUNT)
4. Parsing is now finished
5. early check on the memory config validity
   #+begin_src rust
   GuestMemoryConfig::new(
       blob.ro_data().len() as u64,
       blob.rw_data().len() as u64,
       blob.bss_size() as u64,
       blob.stack_size() as u64,
   )
   .map_err(Error::from_static_str)?;
   #+end_src

   This method does some checks
   + each size is less then VM_MAXIMUM_MEMORY_SIZE (readable memory size)
   + This weird thing: (TODO: not 100% sure why this is not done)
     #+begin_src rust
     // We already checked that these are less than the maximum memory size, so these cannot fail
     // because the maximum memory size is going to be vastly smaller than what an u64 can hold.
     const _: () = {
         assert!(VM_MAXIMUM_MEMORY_SIZE as u64 + VM_PAGE_SIZE as u64 <= u32::MAX as u64);
     };
     #+end_src
   + each value is aligned to the VM_PAGE_SIZE
   + the sum of all the things must be less then VM_MAXIMUM_MEMORY_SIZE
6. Init the Guest Program
    #+begin_src rust
    let init = GuestProgramInit::new()
        .with_ro_data(blob.ro_data())
        .with_rw_data(blob.rw_data())
        .with_bss(blob.bss_size())
        .with_stack(blob.stack_size());
    #+end_src

    `GuestProgramInit` is just a wrapper over the inserted "sections" (are them sections?)
7. NOW WEIRD THINGS ON THE BACKEND TYPE
   1. define `default_backend`, compiler backend seems to be always supported for now (there is a const = true)
   2. the selected backend is the one specified in the Engine, if not the fallback is the `default_backend`
   3. Two Module are create
      1. `CompiledModule` -> if compiler_backend is selected
      2. `InterpretedModule` -> if compiler_backend is selected OR trace_execution is enabled (TODO)
8. creation of `export_index_by_name`
9. exports and import are 're-collected', I think to change the lifetimes
10. At the end the creation of the Module
    the blob is inserted in the module ONLY if debug_trace_execution is activated


** CompiledModule

#+begin_src rust
pub struct CompiledModule {
    sandbox_program: SandboxProgram,
    export_trampolines: Vec<u64>,
}
#+end_src

*** new

1. `Compiler::new(instructions, exports, debug_trace_execution)`, init the compiler
2. `let result = program_assembler.finalize()?;`, finalize the compilation on the `Compiler` object
3. The SandboxProgramInit is initialized with the result of the program_assembler initialization
4. `let sandbox_program = SandboxProgram::new(init).map_err(Error::from_display)?;`
5. extract the trampolines from the result
6. construct the return value, made by the sandbox_program and the export_trampolines

** Compiler


#+begin_src rust
struct Compiler<'a> {
    // Abstraction over the 'real' assembler,
    // this object will manage the produced code
    asm: Assembler,
    // List of all the Exports provided by the guest
    exports: &'a [ProgramExport<'a>],
    // List of all the risc-v quest instruciton
    instructions: &'a [RawInstruction],
    // PC is NOT program counter -> it is the code added in the bytecode by the linker to handle
    // jump even after the transformation by polkavm-linker
    //
    // Initially the code has real address that are then translated by the linker
    // into something else (specified by the jump target instruction) and those are
    // converted into Label address in the final native code
    pc_to_label: HashMap<u32, Label>,
    // PENDING maybe because the label is not defined yet but for sure there is
    // a jump to a new piece of code (represented as a label) that was not covered yet
    pc_to_label_pending: HashMap<u32, Label>,
    // name self explanatory, idk where is used
    next_instruction: Option<RawInstruction>,
    // Should be the max size of the code,
    // to make sure the guest is properly sandboxed
    max_jump_target: u32,
    // TODO
    jump_table: Vec<u8>,
    // For each export is created a Label and this
    // map store the connection between the adress (in the risc-v blob) of an export and the Label associated to it
    // (each label is a trampoline to access the real export code)
    export_to_label: HashMap<u32, Label>,
    // This vec contains the address (in the final code) of the trampolines
    // each values is composed like this:
    // `VM_ADDR_NATIVE_CODE + self.asm.get_label_offset(*label) as u64` where the label is the associated label to the
    // address of the export in the risc-v blob
    export_trampolines: Vec<u64>,
    // Enable or not tracing
    debug_trace_execution: bool,
    // number of the label where an ecall instruction should be handled
    ecall_label: Label,
    // number of the label where a trap instruction should be handled
    trap_label: Label,
    // TODO
    trace_label: Label,

    /// Whether we're coand mostly unimplemented.
    // TODO: Fix this.
    regs_are_64bit: bool,
}
#+end_src


*** new
1. creation of the `Assembler` -> initially empty
2. and then those BOH things:
   #+begin_src rust
   let ecall_label = asm.forward_declare_label();
   let trap_label = asm.forward_declare_label();
   let trace_label = asm.forward_declare_label();
   #+end_src

3. and then just construct the `Compiler` object

*** finalize

we are arrived to the ciccia now! (a little bit of italian, sorry)

return type of the function:
#+begin_src rust
struct CompilationResult<'a> {
    code: &'a [u8],
    jump_table: &'a [u8],
    export_trampolines: &'a [u64],
    sysreturn_address: u64,
}
#+end_src

1. make sure the initial code length of the `Assembler` object is zero
2. set the origin of the code in the `Assembler`
   `self.asm.set_origin(VM_ADDR_NATIVE_CODE);` (VM_ADDR_NATIVE_CODE = 4GiB)
   Why the origin of the code in the Virtual Machine is set up at 4GiB? (TODO: WHY THIS DECISION?)

3. iterate over the instructions

   1. fetch the next_instruction from the `instrucitons` array
   2. get the current length of the code -> `initial_length = self.asm.len()`
   3. fetch the current_instruction from the `instrucitons` array
   4. if trace_execution is enabled and the current_instruction is NOT an Opcode::jump_target
      1. `self.trace_execution(nth_instruction);` -> (TODO)
   5. `instruction.visit(self).map_err(Error::from_static_str)?;`
      1. self=Compiler -> `Compiler` implements `InstructionVisitor`, this means that for each instruction is possible to implement custom logic accepting the `Compiler` as arguments, what is done in the custom logic?

         + mainly here seems to happen all the 'translation' logic between risc-v and x68 instructions, because `visit` is called on the risc-v instruction and inside the method are pushed in the assembler struct the x86 instructions

         How? because the method `visit` for each instruction, in the macro for each variant of the Opcode (inside the RawInstruction) there is a call to `visitor.name_of_instruction` where in this case the visitor is the `Compiler`

   6. LITERALLY THE SAME THING AS POINT 5 WHY!?!??! (TODO)

   7. if NOT enable trace execution then there is a check over the maximum size of the encoded instruction length

4. `self.trap().map_err(Error::from_static_str)?;` adding a trap at the end of the program to make sure it ends correctly
5. "emitting trampolines??" (more or less explained in [[polkavm_assembler_notes]])
   1. if debug_trace_execution -> emit_trace_trampoline (TODO: What?!)
   2. emit_trap_trampoline
   3. emit_ecall_trampoline
   4. emit_export_trampolines
   5. emit_sysreturn
6. make sure that the field `Compiler.pc_to_label_pending` is empty, every label MUST be specified in the Assembler
   This check is present because in the emit trampolines functions the `get_or_forward_declare_label` function could forward declare a label
7. fetch the native pointer size with `core::mem::size_of::<usize>()`
8. resize the jump_table: `self.jump_table.resize((self.max_jump_target as usize + 1) * native_pointer_size, 0);`

   the max_jump_target is updated every time a new jump_target is found, and the jump_target are integers that follows the number fo the block in the linker -> this means that the max_jump_target is also the number of jumps target

    so jump_table is and vec<u8> and is just resized to being able to contain all the needed jump_targets

9. iterate over `pc_to_label` field, and
   the following snipped DOESN'T make any sense for now...
   #+begin_src rust
   for (pc, label) in self.pc_to_label.drain() {
       // PC is the JUMP_TARGET, it should be some sort of incrementer value based on the block the targe is into
       let pc = pc as usize;
       // the range is the space in the jump_table the native address needs to be inserted to be associated with the corrent jump_target
       let range = pc * native_pointer_size..(pc + 1) * native_pointer_size; //
       // the native address associated with the jump_target (pc)
       let address = VM_ADDR_NATIVE_CODE + self.asm.get_label_offset(label) as u64;
       log::trace!("Jump table: [0x{:x}] = 0x{:x}", VM_ADDR_JUMP_TABLE + range.start as u64, address);
       // copy in the jump_table the native address
       self.jump_table[range].copy_from_slice(&address.to_ne_bytes());
   }
    #+end_src
10. Update `export_trampolines`, in this vector will be pushed all the addresses of the trampolines to the final exports,
    in the `emit_export_trampolines` those trampolines were created inside some labels and each label was associated with the address (in risc-v blob) of an exports

    SO: export_trampolines -point_to-> trampoline (a label) -point to-> real export

    #+begin_src rust
    self.export_trampolines.reserve(self.exports.len());
    for export in self.exports {
        let label = self.export_to_label.get(&export.address()).unwrap();
        let native_address = VM_ADDR_NATIVE_CODE + self.asm.get_label_offset(*label) as u64;
        self.export_trampolines.push(native_address);
    }
    #+end_src

11. `let epilogue_length = self.asm.len() - epilogue_start;`, where the epilogue_start was the length of the code in the Assembler finished visiting each instruction, the epilogue must be less than VM_COMPILER_MAXIMUM_EPILOGUE_LENGTH

12. The code in the Assmbler is finalized: `let code = self.asm.finalize()` (TODO)

13. CompilationResult is returned!


*** implementation of InstructionVisitor
for each instruction there is some logic to COMPILE the instruction, a common divisor is a call to the method `push`

example of the `trap` implementation
#+begin_src rust
fn trap(&mut self) -> Self::ReturnTy {
    self.push(jmp_label32(self.trap_label)); // (TODO: understand what and why trap_label (and lables) exists)
    Ok(())
}
#+end_src

`jmp_label32(self.trap_label)` -> this is a call to a method in `polkavm_assembler`, in this crate is implemented a struct for each instruction (I think) and each instruction implements the trait 'polkavm_assembler::Intstruction' needed by the `polkavm::Assembler'

**as we can see here happens the 'recompiling' phase, where from risc-v instructions (trap in this case) we push an amd64 instruction (jmp_label32())**

*** push(instructions)

it just propagate the push of the instruction to the Assembler

*** save_registers_to_vmctx

Save registers to Virtual Machine Context

#+begin_src rust
fn save_registers_to_vmctx(&mut self) {
    if self.regs_are_64bit {
        todo!();
    }

    assert_eq!(Reg::ALL_NON_ZERO.len(), core::mem::size_of_val(VmCtx::new().regs()) / 4);

    self.push(load64_imm(TMP_REG, regs_address()));
    for (nth, reg) in Reg::ALL_NON_ZERO.iter().copied().enumerate() {
        self.push(store_indirect(RegSize::R64, TMP_REG, nth as i32 * 4, conv_reg(reg), StoreKind::U32));
    }
}
#+end_src


*** restore_registers_from_vmctx

Restore registers from the Virtual Context
#+begin_src rust
fn restore_registers_from_vmctx(&mut self) {
    if self.regs_are_64bit {
        todo!();
    }

    // load in the RCX register the address of all the regs
    self.push(load64_imm(TMP_REG, regs_address()));
    for (nth, reg) in Reg::ALL_NON_ZERO.iter().copied().enumerate() {
        // load into each register the prev state
        self.push(load_indirect(conv_reg(reg), RegSize::R64, TMP_REG, nth as i32 * 4, LoadKind::U32));
    }
}
#+end_src

*** get_or_forward_declare_label

#+begin_src rust
fn get_or_forward_declare_label(&mut self, pc: u32) -> Label {
    match self.pc_to_label.get(&pc) {
        // if there is a label associated to a pc then return it
        Some(label) => *label,
        // otherwise
        None => match self.pc_to_label_pending.get(&pc) {
            // if there is a pending label then return it
            Some(label) => *label,
            // otherwise create a new label (with max value in the Assembler)
            None => {
                let label = self.asm.forward_declare_label();
                // TODO
                self.pc_to_label_pending.insert(pc, label);
                label
            }
        },
    }
}
#+end_src


** VmCtx

The virtual machine context.

This is mapped in shared memory and used by the sandbox to keep its state in, as well as by the host to communicate with the sandbox.


** Linker

#+BEGIN_SRC rust
pub struct Linker<T> {
    host_functions: HashMap<String, ExternFnArc<T>>,
    #[allow(clippy::type_complexity)]
    fallback_handler: Option<FallbackHandlerArc<T>>,
    phantom: core::marker::PhantomData<T>,
}
#+END_SRC

T = seems could be a shared state that can be used in the different host functions

*** new(_engine: &Engine)
default values are used, engine is NOT used and T is wrapped into PhantomData and specified alter

*** func_wrap<Params, Args>(&mut self, name: &str, func: impl IntoExternFn<T, Params, Args>)

a way to register statically typed host functions

As we can see the functions must implement `IntoExternFn`, and the implementation of this trait are:

#+begin_src rust
impl_into_extern_fn!(0);
impl_into_extern_fn!(1 A0);
impl_into_extern_fn!(2 A0 A1);
impl_into_extern_fn!(3 A0 A1 A2);
impl_into_extern_fn!(4 A0 A1 A2 A3);
impl_into_extern_fn!(5 A0 A1 A2 A3 A4);
impl_into_extern_fn!(6 A0 A1 A2 A3 A4 A5);
#+end_src

**** What this macro does?

#+begin_src rust
// This is the main branch, entry point of the above calls
//
// Thin branch will later call the @call branches, the main differences are the number of arguments
($arg_count:tt $($args:ident)*) => { ... }

// exampls of @call
(@call $caller:expr, $callback:expr, $a0:ident) => { ... }
(@call $caller:expr, $callback:expr, $a0:ident, $a1:ident) => { ... }
// ...

// Each @call branch will call @check_reg_count and @get_reg
(@check_reg_count $regs_required:expr) => { ... }
(@get_reg $caller:expr) => { ... }
#+end_src


the entry point implements ExternFn for a tuple `(F, PhantomData<(R, $($args),*)>)`
where F is the function that needs to be registered as host function

this means that everything explained here will be repeated by the macro calls with different number arguments

***** Implementation of `ExternFn`

Inside the trait `ExternFn` is implemented the function `call`
#+begin_src rust

// this method is used when it's time to effectively call the host function (I think)
fn call(&self, user_data: &mut T, mut access: BackendAccess, raw: &mut CallerRaw) -> Result<(), Trap> {
    #[allow(unused_mut)]
    // wrap method explained in the section below
    let result = Caller::wrap(user_data, &mut access, raw, move |mut caller| {
        // different branch of the macro
        // impl_into_extern_fn!(@call caller, self.0, $($args),*)

        // example with only one argument
        // impl_into_extern_fn!(@check_reg_count $a0::_REGS_REQUIRED);
        // _REGS_REQUIRED is a method implemented in the trait AbiTy,
        // which is required to be implemented by each argument used in the provided closure
        if $regs_required > Reg::ARG_REGS.len() {
            log::error!("External call failed: too many registers required for arguments!");
            return Err(Trap::default());
        }

        // SCRIVO IN ITALIANO PERCHE" SONO STANCO, E' TARDI:
        //
        // quello che fa la macro @call con all'inerno la macro @get_reg
        // e' quello di andare a chiamare la host function fornita ma andando a pigliare
        // i paramentri di input dai registri del VmCtx
        // questo viene fatto attraverso una closure ritornata da @get_reg
        // che poi viene utilizzta piu' volte al variare dei paramentri richiesti dall funzione
        // attraverso `let a0 = $a0::_get(cb);` che scannerizzera' un registro dopo l'altro

        // TODO: the following part doesn't make sense, LOL
        //let cb = impl_into_extern_fn!(@get_reg $caller);
        let cb = { let mut reg_index = 0;
        let caller = &mut $caller;
        move || -> u32 {
            let value = caller.get_reg(Reg::ARG_REGS[reg_index]);
            reg_index += 1;
            value
        }};

        let a0 = $a0::_get(cb);
        catch_hostcall_panic(|| ($callback)($caller, a0))
    })?;

    let set_reg = {
        let mut reg_index = 0;
        move |value: u32| {
            let reg = Reg::ARG_REGS[reg_index];
            access.set_reg(reg, value);

            if let Some(ref mut tracer) = raw.tracer() {
                tracer.on_set_reg_in_hostcall(reg, value as u32);
            }

            reg_index += 1;
        }
    };
    result._handle_return(set_reg)
}
#+end_src

***** Implementation of `IntoExternFn`

it is implemented TWICE
+ `IntoExternFn<T, ($($args,)*), R>`
+ `IntoExternFn<T, (Caller<'_, T>, $($args,)*), R>`

one with and one without caller

the required method by the trait is `_into_extern_fn`, used in the Linker
the return type is `ExternFnArc` and it is just a wrapper over the callback and some PhantomData

*****  Implementation of `FuncArgs`

#+begin_src rust
impl<$($args: Send + AbiTy,)*> FuncArgs for ($($args,)*) {
    const _PRIVATE_EXTERN_TY: &'static [ExternTy] = &[ // --> This is used to check at compile time
        $(<$args as AbiTy>::_PRIVATE_EXTERN_TY,)*      // the arguments passed to the exported function
    ];                                                 // of the blob

    // this function will set the registers of the VmCtx to the arguments
    // this is used to call an exported function by the blob to set up all the register
    // and then call the function
    #[allow(unused_mut)]
    #[allow(unused_variables)]
    #[allow(non_snake_case)]
    fn _set(self, mut set_reg: impl FnMut(u32)) {
        let ($($args,)*) = self;
        $($args._set(&mut set_reg);)*
    }
}
#+end_src

#+RESULTS:
: error: Could not compile `cargoOWG3Z1`.



*** func_new(&mut self, name: &str, ty: FuncType, func: impl Fn(Caller<'_, T>, &[Val], Option<&mut Val>) -> Result<(), Trap> + Send + Sync + 'static,)

a way to register dynamically typed host functions


*** instantiate_pre(&self, module: &Module)

Link exports value of the module to registered host functions in the Linker

There are various check everything is correct between what specified in the import of the blob and what provided to the linker thanks to func_wrap and func_new

return a InstancePre struct,

**** How it works? (TODO)


** Caller

#+begin_src rust
/// A handle used to access the execution context.
pub struct Caller<'a, T> {
    raw: &'a mut CallerRaw,
    lifetime: *mut Option<Rc<()>>,
    _phantom: core::marker::PhantomData<&'a mut T>,
}
#+end_src

*** wrap

this method accept everythin needed to construct a Caller and a callback function, the callback is the provided host function, callable from the inside of the risc-v blob as import

What the method does is a little bit weird:

#+begin_src rust
pub(crate) fn wrap<R>(
    user_data: &mut T,
    access: &'a mut BackendAccess<'_>,
    raw: &'a mut CallerRaw,
    callback: impl FnOnce(Self) -> R,
) -> R
where
    T: 'a,
{
    raw.user_data = user_data as *mut T as *mut core::ffi::c_void;
    raw.access = access as *mut BackendAccess as *mut core::ffi::c_void;

    let mut lifetime = None;
    let caller = Caller {
        raw,
        lifetime: &mut lifetime,
        _phantom: core::marker::PhantomData,
    };

    let result = callback(caller);

    core::mem::drop(lifetime);
    result
}
#+end_src


** InstancePre
#+BEGIN_SRC rust
pub struct InstancePre<T>(Arc<InstancePrePrivate<T>>);
#+END_SRC

this is something like a wrapper over the Module and the Host Functions

*** instantiate
the pre instance can be instantiated in two ways Compiled or Interpreted with the Tracing enabled

1. a backend is instatiated, it could be
   + InstanceBackend::Compiled(CompiledInstance)
   + InstanceBackend::Interpreted(InterpretedInstance)

*** get_typed_func<FnArgs, FnResult>(&self, name: &str)
Returns a **typed** handle to a function of a given name exported by the module.

*** get_func(&self, name: &str)
Returns a handle to a function of a given name exported by the module.

** CompiledInstance

#+begin_src rust
pub(crate) struct CompiledInstance {
    module: Module,
    sandbox: Sandbox,
}
#+end_src

*** new(Module) -> CompiledInstance

1. get the CompiledModule from the Module
2. Init SandboxConfig (logger enabled only if is_debug_trace_execution_enabled)
3. `Sandbox::Spawn`
4. TODO

** SandboxConfig


** RawInstruction

#+begin_src rust
 pub struct RawInstruction {
     //ok, just the opcode of the instruction
     //it could be seen as the "identifier" of the instruction in the binary format
     op: u8,
     // maybe the register used in the instruction? (TODO)
     regs: u8,
     // LOL IDK (TODO)
     imm_or_reg: u32,
 }
#+end_src

There seem to be only 4 types of opcodes:
- name_argless :: (&mut self), no input args
- name_with_imm :: (&mut self, imm: u32), only one arg
- name_with_regs3 :: (&mut self, reg1: Reg, reg2: Reg, reg3: Reg), three registers as input
- name_with_regs2_imm :: (&mut self, reg1: Reg, reg2: Reg, imm: u32), 2 registers and imm input

How instructions are defined?
+ `define_opcodes!` accept the opcodes and its binary values,
  the opcodes are divided as before
+ the macro define a trait `InstructionVisitor` that requires to self to implement a method for each instruction
  + this trait is implemented by `core::fmt::Formatter`
+ then the method `visit` is implemented for `RawInstruction`
  + What it does is to accept `impl InstructionVisitor` and match on the Opcode to call the proper method on the `impl InstructionVisitor`, the only struct to implement this trait is `core::fmt::formatter` -> this let me think how this method is used to just 'debug' instructions in fact:
    #+begin_src rust
    impl core::fmt::Display for RawInstruction {
        fn fmt(&self, fmt: &mut core::fmt::Formatter) -> core::fmt::Result {
            self.visit(fmt)
        }
    }
    #+end_src
    visit is just used in the `Display` method
+ After the things with the `InstructionVisitor` trait there is another call to the `define_opcodes!` macro, but another branch:
  #+begin_src rust
  define_opcodes!(
      @impl_shared
      $($name_argless = $value_argless,)+
      $($name_with_imm = $value_with_imm,)+
      $($name_with_regs3 = $value_with_regs3,)+
      $($name_with_regs2_imm = $value_with_regs2_imm,)+
  );
  #+end_src
  as we can see the division between the different instructions is removed, the marco indeed accept only a list of `name = value`
  #+begin_src rust
    (@impl_shared $($name:ident = $value:expr,)+) => { ... }
  #+end_src
  + What this branch does?
    #+begin_src rust
    // It define an enum to represent all the opcodes

    #[repr(u8)] // in a fieldless enum what this does is to treat
                // at runtime the enum literally like an u8, so the value
                // is associated to each variant
                // more infos: https://doc.rust-lang.org/nomicon/other-reprs.html#repru-repri
    // + other derive
    pub enum Opcode {
        $(
            $name = $value,
        )+
    }

    // Implementation of a method able to convert a byte to an opcode
    impl Opcode {
        pub fn from_u8(byte: u8) -> Option<Opcode> {
            match byte {
                $($value => Some(Opcode::$name),)+
                _ => None
            }
        }
    }

    // and then construct a 256 value slice to store which opcodes are valid
    const IS_INSTRUCTION_VALID_CONST: [bool; 256] = {
        let mut is_valid = [false; 256];
        $(
            is_valid[$value] = true;
        )+
        is_valid
    };
    #+end_src

**What are though `regs` and `imm_or_reg`???**

useful things to know:
+ `Reg` enum :: there are 14 variants (so 14 registers?)
+ ALL_NON_ZERO :: is a const array containing the list of all of the VM's registers, except the zero register.
+ ARG_REGS :: const array of all argument registers
+ MAX_INSTRUCTION_LENGTH :: it is the max length of a register, it is evaluated ad `MAX_VARINT_LENGTH + 2`, where `MAX_VARINT_LENGTH = 5`

*** List of all instructions

|---------------------------------------+-------------|
| 1 byte instructions                   |             |
| Instructions with no args.            |             |
|---------------------------------------+-------------|
| trap                                  | 0b00_000000 |
|---------------------------------------+-------------|
| 1-6 byte instructions                 |             |
| Instructions with args: imm           |             |
|---------------------------------------+-------------|
| jump_target                           | 0b01_000000 |
| ecalli                                | 0b01_111111 |
|---------------------------------------+-------------|
| 3 byte instructions                   |             |
| Instructions with args: reg, reg, reg |             |
|---------------------------------------+-------------|
| set_less_than_unsigned                | 0b10_000000 |
| set_less_than_signed                  | 0b10_000001 |
| shift_logical_right                   | 0b10_000010 |
| shift_arithmetic_right                | 0b10_000011 |
| shift_logical_left                    | 0b10_000100 |
| or                                    | 0b10_000101 |
| and                                   | 0b10_000110 |
| xor                                   | 0b10_000111 |
| add                                   | 0b10_001000 |
| sub                                   | 0b10_001001 |
| mul                                   | 0b10_010000 |
| mul_upper_signed_signed               | 0b10_010001 |
| mul_upper_unsigned_unsigned           | 0b10_010010 |
| mul_upper_signed_unsigned             | 0b10_010011 |
| div_unsigned                          | 0b10_010100 |
| div_signed                            | 0b10_010101 |
| rem_unsigned                          | 0b10_010110 |
| rem_signed                            | 0b10_010111 |
|---------------------------------------+-------------|
| 2-7 byte instructions                 |             |
| Instructions with args: reg, reg, imm |             |
|---------------------------------------+-------------|
| set_less_than_unsigned_imm            | 0b11_000000 |
| set_less_than_signed_imm              | 0b11_000001 |
| shift_logical_right_imm               | 0b11_000010 |
| shift_arithmetic_right_imm            | 0b11_000011 |
| shift_logical_left_imm                | 0b11_000100 |
| or_imm                                | 0b11_000101 |
| and_imm                               | 0b11_000110 |
| xor_imm                               | 0b11_000111 |
| add_imm                               | 0b11_001000 |
| store_u8                              | 0b11_010000 |
| store_u16                             | 0b11_010010 |
| store_u32                             | 0b11_010100 |
| load_u8                               | 0b11_100000 |
| load_i8                               | 0b11_100001 |
| load_u16                              | 0b11_100010 |
| load_i16                              | 0b11_100011 |
| load_u32                              | 0b11_100100 |
| branch_less_unsigned                  | 0b11_110000 |
| branch_less_signed                    | 0b11_110001 |
| branch_greater_or_equal_unsigned      | 0b11_110010   |
| branch_greater_or_equal_signed        | 0b11_110011 |
| branch_eq                             | 0b11_110100 |
| branch_not_eq                         | 0b11_110101 |
| jump_and_link_register                | 0b11_111111 |
|---------------------------------------+-------------|

**** Structure of an instruction
***** 1֯ byte = opcode
****** if opcode_msb = 0 and (opcode_msb - 1) = 0
END, the instruction is 1B long
****** else if opcode_msb = 0 and (opcode_msb - 1) = 1
******* 2֯ to 6֯ byte = immediate
the immediate value is varint encoded
****** else if opcode_msb = 1 and (opcode_msb - 1) = 0
******* 2֯ byte = reg2 & reg1
******* 3֯ byte = reg3
****** else if opcode_msb = 1 and (opcode_msb - 1) = 1
******* 2֯ byte = reg2 & reg1
******* 3֯ to 7֯ byte = immediate
the immediate value is varint encoded

*** new_argless(opcode)
just a `RawInstruction` with no args, only the opcode
*** new_with_imm(opcode, imm)
*** new_with_regs3(opcode, reg1, reg2, reg3)
*** new_with_regs2_imm(opcode, reg1, reg2, imm)
*** op
just return the enum Opcode
*** reg1
return an enum Reg, the reg1 is the lsh (least significant half) of `regs` -> `self.regs & 0b00001111`
*** reg2
return an enum Reg, the reg2 is the msh (most significant half) of `regs` -> `self.regs >> 4`
*** reg3
return an enum Reg, the reg3 is stored in `imm_or_reg`
*** raw_op
*** raw_imm_or_reg

*** deserialize

#+begin_src rust
pub fn deserialize(input: &[u8]) -> Option<(usize, Self)> { ... }
#+end_src

The return type is a tuple, why?:
+ usize -> length of the encode instruction (bytes)
+ RawInstruction -> deserialized instruction

What the function does?
1. read the first byte to extract the opcode and make sure it is valid using the `IS_INSTRUCTION_VALID` array
2. set the position to 1
3. check the msb to see if REG1 and REG2 are present (second byte)
   1. Check if the registers are valid, registers could be in the two halfs of the byte only values from 0 to 13, NOT 14 or 15
4. check msb or (msb - 1)
   1. the third thing could be REG3 (third byte) or an immediate value varint encoded (5B max)
5. return the decoded instruciton and its encoded length

*** serialize_into(buffer)
1. make sure the buffer is enough big (MAX_INSTRUCTION_LENGTH)
2. store the opcode in the position 0
3. write regs in position 1 if the opcode expect registers
4. write the imm_or_reg in position 1 or 2 if expected by the register

*** TESTs
(TODO: skipped for now)
