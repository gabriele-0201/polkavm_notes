* Possible Error:
** crates/polkavm-common/src/abi.rs
line 94

#+begin_src rust
// We already checked that these are less than the maximum memory size, so these cannot fail
// because the maximum memory size is going to be vastly smaller than what an u64 can hold.
const _: () = {
    assert!(VM_MAXIMUM_MEMORY_SIZE as u64 + VM_PAGE_SIZE as u64 <= u32::MAX as u64);
};
#+end_src

smaller than what an u64 can hold. -> smaller than what an **u32** can hold.

** crates/polkavm/src/api.rs
line 222


#+begin_src rust
GuestMemoryConfig::new(
    blob.ro_data().len() as u64,
    blob.rw_data().len() as u64,
    blob.bss_size() as u64,
    blob.stack_size() as u64,
)
.map_err(Error::from_static_str)?;

let init = GuestProgramInit::new() // <--- this is done anyway
    .with_ro_data(blob.ro_data())
    .with_rw_data(blob.rw_data())
    .with_bss(blob.bss_size())
    .with_stack(blob.stack_size());
#+end_src

can be substitute with:
#+begin_src rust
let init = GuestProgramInit::new() // <--- this is done anyway
    .with_ro_data(blob.ro_data())
    .with_rw_data(blob.rw_data())
    .with_bss(blob.bss_size())
    .with_stack(blob.stack_size());

init.memory_config()?; // <-----
#+end_src

** crates/polkavm_assembler/src/assembler.rs
line 167

the method can panic if N > 15 -> maybe better to put an assertion in method `append_array`? Just to not panic at runtime

** crates/polkavm_assembler/src/amd64.rs
line 154

#+begin_src rust
let xs = value.to_le_bytes();
enc.append_array([xs[0], xs[1], xs[2], xs[3]])

// why not?
enc.append_array(value.to_le_bytes());
#+end_src

** crates/polkavm_derive_impl/src/import.rs

In this code `parse_import_attributes` return a Vec BUT `import_index` is an Option<u32>

#+begin_src rust
if let Some(attributes) = parse_import_attributes(&attr)? {
    for attribute in attributes {
        match attribute {
            ImportAttribute::Index(index) => {
                import_index = Some(index);
            }
        }
    }

    continue;
}
#+end_src
*** there are two problems
**** 1.
#+begin_src rust
// this code
match attribute {
    ImportAttribute::Index(index) => {
        import_index = Some(index);
    }
}

//could be reduced to this
if let ImportAttribute::Index(index) = attribute {
        import_index = Some(index);
}
#+end_src

**** 2.
`import_index` will assume the value of the LAST element in the Vec, is that normal? Why a single function inside an extern block can have multiple index specified??

** example/host

to get function of of the linker (an export) you need to specify the arguments and if is more than one then you need to use tuples, BUT if you use only one argument you need to use this SUPER weird syntax (A,)

#+begin_src rust
let fn_typed = instance.get_typed_func::<(u32,), ()>("add_n").unwrap();
// even then you call the function
fn_typed.call(&mut storage, (2,)).unwrap();
#+end_src

Solution -> add another branch in the impl_into_extern_fn! macro and just implement FuncArgs for A0 and not (A0,)
